
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>app_log.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file app_log.c</a>
<a name="ln3"> * @author Otso Jousimaa &lt;otso@ojousima.net&gt;</a>
<a name="ln4"> * @date 2020-07-17</a>
<a name="ln5"> *       2021-11-29 DG12 Change m_boot_count from uint16 to 32</a>
<a name="ln6"> *                  Use TESTABLE_STATIC</a>
<a name="ln7"> *       2021-05-06 includes Potential fix for #255 (#256)</a>
<a name="ln8"> * @brief</a>
<a name="ln9"> * Save and retrieve sensor readings to/from flash</a>
<a name="ln10"> *  for transmitting to station for sync.</a>
<a name="ln11"> * Allocate static input, output and config memory.</a>
<a name="ln12"> * Readings are blocked into a nearly page size buffer.</a>
<a name="ln13"> * store_block by bumping index up to _DATA_RECORDS_NUM then wrap.</a>
<a name="ln14"> * _log_process establish time for next sample</a>
<a name="ln15"> *              if it's time, collect sensor data and add to input_block and</a>
<a name="ln16"> *              if full write it to flash</a>
<a name="ln17"> * _init log config_set/get to/from flash. and boot_count and</a>
<a name="ln18"> *          _purge_logs erases all log records then garbage collection.</a>
<a name="ln19"> * Use FDS record access routines (not fstore page routines)</a>
<a name="ln20"> *  via rt_flash_free, _store, _load and _flash_gc_run</a>
<a name="ln21"> * Possible fatal error from FDS: delete SPACE_IN_QUEUES,</a>
<a name="ln22"> * https://infocenter.nordicsemi.com/topic/com.nordic.infocenter.sdk5.v15.0.0/lib_fds_functionality.html</a>
<a name="ln23"> *</a>
<a name="ln24"> * (_) ToDo Save RAM by fetchihng sync data directly from flash and elimitating input_block buffer.</a>
<a name="ln25"> *</a>
<a name="ln26"> * @copyright Ruuvi Innovations Ltd, license BSD-3-Clause.</a>
<a name="ln27"> */</a>
<a name="ln28">#include &quot;app_log.h&quot;</a>
<a name="ln29"> </a>
<a name="ln30">#include &quot;app_config.h&quot;</a>
<a name="ln31">#include &quot;app_testing.h&quot;</a>
<a name="ln32">#include &quot;ruuvi_driver_error.h&quot;</a>
<a name="ln33">#include &quot;ruuvi_driver_sensor.h&quot;</a>
<a name="ln34">#include &quot;ruuvi_library.h&quot;</a>
<a name="ln35">#include &quot;ruuvi_library_compress.h&quot;</a>
<a name="ln36">#include &quot;ruuvi_interface_log.h&quot;</a>
<a name="ln37">#include &quot;ruuvi_interface_yield.h&quot;</a>
<a name="ln38">#include &quot;ruuvi_task_flash.h&quot;</a>
<a name="ln39"> </a>
<a name="ln40">#if RT_FLASH_ENABLED</a>
<a name="ln41"> </a>
<a name="ln42">#ifndef LOGI</a>
<a name="ln43">static inline void LOGI (const char * const msg)</a>
<a name="ln44">{</a>
<a name="ln45">    ri_log (RI_LOG_LEVEL_INFO, msg);</a>
<a name="ln46">}</a>
<a name="ln47">#endif</a>
<a name="ln48"> </a>
<a name="ln49">#ifndef LOGD</a>
<a name="ln50">static inline void LOGD (const char * const msg)</a>
<a name="ln51">{</a>
<a name="ln52">    ri_log (RI_LOG_LEVEL_DEBUG, msg);</a>
<a name="ln53">}</a>
<a name="ln54">#endif</a>
<a name="ln55"> </a>
<a name="ln56">/**</a>
<a name="ln57"> * @addtogroup app_log</a>
<a name="ln58"> */</a>
<a name="ln59">/** @{ */</a>
<a name="ln60"> </a>
<a name="ln61">TESTABLE_STATIC app_log_record_t m_log_input_block;     //!&lt; Block to be stored to flash.</a>
<a name="ln62">TESTABLE_STATIC app_log_record_t</a>
<a name="ln63">m_log_output_block;    //!&lt; Block read from flash for examination.</a>
<a name="ln64"> </a>
<a name="ln65">TESTABLE_STATIC app_log_config_t m_log_config;          //!&lt; Configuration for logging.</a>
<a name="ln66">TESTABLE_STATIC uint64_t</a>
<a name="ln67">m_last_sample_ms;      //!&lt; Timestamp of last processed sample.</a>
<a name="ln68">TESTABLE_STATIC uint32_t         m_boot_count = 0;</a>
<a name="ln69"> </a>
<a name="ln70"> </a>
<a name="ln71">/* @brief Start at next block number from where we left off.</a>
<a name="ln72"> *          Free, GC, Store */        /* this code is kind &quot;hinky&quot; ?? DG */</a>
<a name="ln73">// // // // // // /           // // // // // // // // // //</a>
<a name="ln74">static rd_status_t store_block (const app_log_record_t * const p_record)</a>
<a name="ln75">{</a>
<a name="ln76">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln77">    uint8_t num_tries = 0;</a>
<a name="ln78">    static uint8_t record_idx = 0;</a>
<a name="ln79"> </a>
<a name="ln80">    do</a>
<a name="ln81">    {</a>
<a name="ln82">        uint8_t  record_slot = (record_idx + num_tries) %</a>
<a name="ln83">                               APP_FLASH_LOG_DATA_RECORDS_NUM; // if while went past the end, wrap</a>
<a name="ln84">        uint16_t target_record = (APP_FLASH_LOG_DATA_RECORD_PREFIX &lt;&lt; 8u) + record_slot;</a>
<a name="ln85">        err_code = rt_flash_free (APP_FLASH_LOG_FILE,</a>
<a name="ln86">                                  target_record);                       //  free old one to GC and wait</a>
<a name="ln87">        char msg[128];</a>
<a name="ln88"> </a>
<a name="ln89">        if (RD_SUCCESS == err_code) // It's not a problem if there wasn't old block to erase.</a>
<a name="ln90">        {</a>
<a name="ln91">            snprintf (msg, sizeof (msg), &quot;store_block:freed old record #%04X\n&quot;, target_record);</a>
<a name="ln92">            LOGI (msg);</a>
<a name="ln93">        }</a>
<a name="ln94">        else</a>
<a name="ln95">        {</a>
<a name="ln96">            snprintf (msg, sizeof (msg), &quot;store_block:creating new record #%04X\n&quot;, target_record);</a>
<a name="ln97">            LOGI (msg);</a>
<a name="ln98">        }</a>
<a name="ln99"> </a>
<a name="ln100">        err_code &amp;=</a>
<a name="ln101">            ~RD_ERROR_NOT_FOUND;    // clear NOT_FOUND      ?? shouldn't we wait until it done ??</a>
<a name="ln102"> </a>
<a name="ln103">        while (rt_flash_busy()) { ri_yield(); }</a>
<a name="ln104"> </a>
<a name="ln105">        err_code |=</a>
<a name="ln106">            rt_flash_gc_run ();                                                     // Garabage Collection and wait</a>
<a name="ln107"> </a>
<a name="ln108">        while (rt_flash_busy()) { ri_yield(); }</a>
<a name="ln109"> </a>
<a name="ln110">        err_code |= rt_flash_store (APP_FLASH_LOG_FILE,</a>
<a name="ln111">                                    target_record,                      // store it and wait</a>
<a name="ln112">                                    p_record, sizeof (app_log_record_t));</a>
<a name="ln113"> </a>
<a name="ln114">        while (rt_flash_busy()) { ri_yield(); }</a>
<a name="ln115"> </a>
<a name="ln116">        RD_ERROR_CHECK (err_code, ~RD_ERROR_FATAL);</a>
<a name="ln117">        num_tries++;             // Try the next block if there was error.</a>
<a name="ln118">    } while ( (RD_SUCCESS != err_code) &amp;&amp; (num_tries &lt; APP_FLASH_LOG_DATA_RECORDS_NUM));</a>
<a name="ln119"> </a>
<a name="ln120">    if (RD_SUCCESS == err_code)</a>
<a name="ln121">    {</a>
<a name="ln122">        record_idx +=</a>
<a name="ln123">            num_tries;                                    // next time start at next page the one we used</a>
<a name="ln124">        record_idx = record_idx %</a>
<a name="ln125">                     APP_FLASH_LOG_DATA_RECORDS_NUM;   // start back at 0 if we went too far</a>
<a name="ln126">    }</a>
<a name="ln127"> </a>
<a name="ln128">    return err_code;</a>
<a name="ln129">}</a>
<a name="ln130">// // // // // // /           // // // // // // // // // //</a>
<a name="ln131">static rd_status_t purge_logs (void)</a>
<a name="ln132">{</a>
<a name="ln133">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln134">    LOGI (&quot;Free all &amp; GC\n&quot;);</a>
<a name="ln135"> </a>
<a name="ln136">    for (uint8_t record_idx = 0; record_idx &lt; APP_FLASH_LOG_DATA_RECORDS_NUM; record_idx++)</a>
<a name="ln137">    {</a>
<a name="ln138">        err_code |= rt_flash_free (APP_FLASH_LOG_FILE,</a>
<a name="ln139">                                   (APP_FLASH_LOG_DATA_RECORD_PREFIX &lt;&lt; 8u) + record_idx);</a>
<a name="ln140"> </a>
<a name="ln141">        while (rt_flash_busy()) { ri_yield(); }</a>
<a name="ln142">    }</a>
<a name="ln143"> </a>
<a name="ln144">    err_code &amp;= ~RD_ERROR_NOT_FOUND; // It doesn't matter if there was no data to erase.</a>
<a name="ln145">    err_code |= rt_flash_gc_run ();</a>
<a name="ln146">    return err_code;</a>
<a name="ln147">}</a>
<a name="ln148">// // // // // // // // // // // //                // // //</a>
<a name="ln149">TESTABLE_STATIC rd_status_t app_log_read_boot_count (</a>
<a name="ln150">    void)   // should be called load, bump, store</a>
<a name="ln151">{</a>
<a name="ln152">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln153">    err_code |= rt_flash_load (APP_FLASH_LOG_FILE,</a>
<a name="ln154">                               APP_FLASH_LOG_BOOT_COUNTER_RECORD,           // load</a>
<a name="ln155">                               &amp;m_boot_count, sizeof (m_boot_count));</a>
<a name="ln156"> </a>
<a name="ln157">    if ( (RD_SUCCESS == err_code) || (RD_ERROR_NOT_FOUND == err_code))</a>
<a name="ln158">    {</a>
<a name="ln159">        m_boot_count++;</a>
<a name="ln160">        err_code = rt_flash_store (APP_FLASH_LOG_FILE,</a>
<a name="ln161">                                   APP_FLASH_LOG_BOOT_COUNTER_RECORD,       // bump and store</a>
<a name="ln162">                                   &amp;m_boot_count, sizeof (m_boot_count));</a>
<a name="ln163">    }</a>
<a name="ln164"> </a>
<a name="ln165">    char msg[128];</a>
<a name="ln166">    snprintf (msg, sizeof (msg), &quot;Boot count: %ld\n&quot;, m_boot_count);</a>
<a name="ln167">    LOGI (msg);</a>
<a name="ln168">    return err_code;</a>
<a name="ln169">}</a>
<a name="ln170"> </a>
<a name="ln171">// // // // // /         / // // // // // // // // // // //</a>
<a name="ln172">/* @brief load config (stores defaults the first time)  */</a>
<a name="ln173">rd_status_t app_log_init (void)</a>
<a name="ln174">{</a>
<a name="ln175">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln176">    // Defaults get overwritten by flash load and stored if the load fails.</a>
<a name="ln177">    app_log_config_t config =</a>
<a name="ln178">    {</a>
<a name="ln179">        .interval_s = APP_LOG_INTERVAL_S,</a>
<a name="ln180">        .overflow   = APP_LOG_OVERFLOW,</a>
<a name="ln181">        .fields = {</a>
<a name="ln182">            .datas.temperature_c = APP_LOG_TEMPERATURE_ENABLED,</a>
<a name="ln183">            .datas.humidity_rh   = APP_LOG_HUMIDITY_ENABLED,</a>
<a name="ln184">            .datas.pressure_pa   = APP_LOG_PRESSURE_ENABLED</a>
<a name="ln185">        }</a>
<a name="ln186">    };</a>
<a name="ln187">#   if APP_FLASH_LOG_CONFIG_NVM_ENABLED</a>
<a name="ln188">    err_code = rt_flash_load (APP_FLASH_LOG_FILE, APP_FLASH_LOG_CONFIG_RECORD,</a>
<a name="ln189">                              &amp;config, sizeof (config));</a>
<a name="ln190">#   endif</a>
<a name="ln191"> </a>
<a name="ln192">    if (RD_ERROR_NOT_FOUND == err_code) //-V547</a>
<a name="ln193">    {</a>
<a name="ln194">        err_code = rt_flash_store (APP_FLASH_LOG_FILE, APP_FLASH_LOG_CONFIG_RECORD,</a>
<a name="ln195">                                   &amp;config, sizeof (config));</a>
<a name="ln196">    }</a>
<a name="ln197"> </a>
<a name="ln198">    if (RD_SUCCESS == err_code) //-V547</a>
<a name="ln199">    {</a>
<a name="ln200">        memcpy (&amp;m_log_config, &amp;config, sizeof (config));</a>
<a name="ln201">        LOGI (&quot;purge\n&quot;);</a>
<a name="ln202">        err_code |= purge_logs();</a>
<a name="ln203">    }</a>
<a name="ln204"> </a>
<a name="ln205">    err_code |= app_log_read_boot_count();</a>
<a name="ln206">    return err_code;</a>
<a name="ln207">}</a>
<a name="ln208">// // // // // //             // // // // // // // // // //</a>
<a name="ln209">rd_status_t app_log_process (const rd_sensor_data_t * const sample)</a>
<a name="ln210">{</a>
<a name="ln211">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln212">    uint64_t next_sample_ms = m_last_sample_ms + (m_log_config.interval_s * 1000u);</a>
<a name="ln213">    uint32_t end_timestamp = m_log_input_block.end_timestamp_s;</a>
<a name="ln214">    LOGD (&quot;Sample received\n&quot;);</a>
<a name="ln215"> </a>
<a name="ln216">    if (0 == m_last_sample_ms) { next_sample_ms = 0; } // Always store first sample.</a>
<a name="ln217"> </a>
<a name="ln218">    if (next_sample_ms &lt;= sample-&gt;timestamp_ms) //Check if new sample should be processed</a>
<a name="ln219">    {</a>
<a name="ln220">        LOGD (&quot;Storing sample\n&quot;);</a>
<a name="ln221">        app_log_element_t element =</a>
<a name="ln222">        {</a>
<a name="ln223">            .timestamp_s   = sample-&gt;timestamp_ms / 1000u,</a>
<a name="ln224">            .temperature_c = rd_sensor_data_parse (sample, RD_SENSOR_TEMP_FIELD),</a>
<a name="ln225">            .humidity_rh   = rd_sensor_data_parse (sample, RD_SENSOR_HUMI_FIELD),</a>
<a name="ln226">            .pressure_pa   = rd_sensor_data_parse (sample, RD_SENSOR_PRES_FIELD),</a>
<a name="ln227">        };</a>
<a name="ln228"> </a>
<a name="ln229">        if (APP_LOG_MAX_SAMPLES &gt; m_log_input_block.num_samples)</a>
<a name="ln230">        { m_log_input_block.storage[m_log_input_block.num_samples++] = element; }</a>
<a name="ln231"> </a>
<a name="ln232">        if (m_log_input_block.num_samples &gt;= APP_LOG_MAX_SAMPLES)</a>
<a name="ln233">        {</a>
<a name="ln234">            LOGI (&quot;Storing block\n&quot;);</a>
<a name="ln235">            err_code |= store_block (&amp;m_log_input_block);</a>
<a name="ln236">            RD_ERROR_CHECK (err_code, RD_SUCCESS);</a>
<a name="ln237">            memset (&amp;m_log_input_block, 0, sizeof (m_log_input_block));         // zero input_block</a>
<a name="ln238">            m_log_input_block.start_timestamp_s = end_timestamp;</a>
<a name="ln239">        }</a>
<a name="ln240"> </a>
<a name="ln241">        m_last_sample_ms = sample-&gt;timestamp_ms;</a>
<a name="ln242">        m_log_input_block.end_timestamp_s = sample-&gt;timestamp_ms / 1000U;</a>
<a name="ln243">    }</a>
<a name="ln244"> </a>
<a name="ln245">    return err_code;</a>
<a name="ln246">}</a>
<a name="ln247"> </a>
<a name="ln248">/**</a>
<a name="ln249"> * @brief Load new block to be read if needed.</a>
<a name="ln250"> *</a>
<a name="ln251"> * Can also copy input block to</a>
<a name="ln252"> * output block if there's no more stored blocks in flash.</a>
<a name="ln253"> */</a>
<a name="ln254">// // // // // // // // // /              // // // // // //</a>
<a name="ln255">static rd_status_t app_log_read_load_block (app_log_read_state_t * const p_rs)</a>
<a name="ln256">{</a>
<a name="ln257">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln258"> </a>
<a name="ln259">    if ( (0 == p_rs-&gt;element_idx)</a>
<a name="ln260">            &amp;&amp; (0 == p_rs-&gt;page_idx))</a>
<a name="ln261">    {</a>
<a name="ln262">        // Clear out previous state</a>
<a name="ln263">        err_code |= rt_flash_load (APP_FLASH_LOG_FILE,</a>
<a name="ln264">                                   (APP_FLASH_LOG_DATA_RECORD_PREFIX &lt;&lt; 8u) + p_rs-&gt;page_idx,</a>
<a name="ln265">                                   &amp;m_log_output_block, sizeof (m_log_output_block));</a>
<a name="ln266">        p_rs-&gt;page_idx++;</a>
<a name="ln267">    }</a>
<a name="ln268">    else if ( (APP_FLASH_LOG_DATA_RECORDS_NUM &gt; p_rs-&gt;page_idx)</a>
<a name="ln269">              &amp;&amp; (p_rs-&gt;element_idx &gt;= m_log_output_block.num_samples))</a>
<a name="ln270">    {</a>
<a name="ln271">        // Returns NOT_FOUND if page IDX is not in flash.</a>
<a name="ln272">        err_code |= rt_flash_load (APP_FLASH_LOG_FILE,</a>
<a name="ln273">                                   (APP_FLASH_LOG_DATA_RECORD_PREFIX &lt;&lt; 8u) + p_rs-&gt;page_idx,</a>
<a name="ln274">                                   &amp;m_log_output_block, sizeof (m_log_output_block));</a>
<a name="ln275">        p_rs-&gt;page_idx++;</a>
<a name="ln276">        p_rs-&gt;element_idx = 0;</a>
<a name="ln277">    }</a>
<a name="ln278">    else if ( (APP_FLASH_LOG_DATA_RECORDS_NUM == p_rs-&gt;page_idx)</a>
<a name="ln279">              &amp;&amp; (p_rs-&gt;element_idx &gt;= m_log_output_block.num_samples))</a>
<a name="ln280">    {</a>
<a name="ln281">        memcpy (&amp;m_log_output_block, &amp;m_log_input_block, sizeof (m_log_output_block));</a>
<a name="ln282">        p_rs-&gt;page_idx++;</a>
<a name="ln283">        p_rs-&gt;element_idx = 0;</a>
<a name="ln284">    }</a>
<a name="ln285">    else {} // No action needed.</a>
<a name="ln286"> </a>
<a name="ln287">    // Zero out state if block was not found</a>
<a name="ln288">    if (RD_ERROR_NOT_FOUND == err_code)</a>
<a name="ln289">    {</a>
<a name="ln290">        memset (&amp;m_log_output_block, 0, sizeof (m_log_output_block));</a>
<a name="ln291">    }</a>
<a name="ln292"> </a>
<a name="ln293">    return err_code;</a>
<a name="ln294">}</a>
<a name="ln295"> </a>
<a name="ln296">/**</a>
<a name="ln297"> * @brief Forward read state to first next valid element.</a>
<a name="ln298"> *  internal</a>
<a name="ln299"> * @retval RD_SUCCESS p_rs points to a valid element</a>
<a name="ln300"> * @retval RD_ERROR_NOT_FOUND if block doesn't have a valid element.</a>
<a name="ln301"> */</a>
<a name="ln302">// // // // // // // // //                   // // // // //</a>
<a name="ln303">static rd_status_t app_log_read_fast_forward (app_log_read_state_t * const p_rs)</a>
<a name="ln304">{</a>
<a name="ln305">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln306">    uint64_t ts_s  = m_log_output_block.storage[p_rs-&gt;element_idx].timestamp_s;</a>
<a name="ln307">    uint64_t ts_ms = ts_s * 1000LLU;</a>
<a name="ln308"> </a>
<a name="ln309">    while ( (p_rs-&gt;oldest_element_ms &gt; ts_ms)</a>
<a name="ln310">            &amp;&amp; (p_rs-&gt;element_idx &lt; m_log_output_block.num_samples))</a>
<a name="ln311">    {</a>
<a name="ln312">        ts_s  = m_log_output_block.storage[p_rs-&gt;element_idx].timestamp_s;</a>
<a name="ln313">        ts_ms = ts_s * 1000LLU;</a>
<a name="ln314">        p_rs-&gt;element_idx++;</a>
<a name="ln315">    }</a>
<a name="ln316"> </a>
<a name="ln317">    if (p_rs-&gt;element_idx &gt;= m_log_output_block.num_samples) { err_code |= RD_ERROR_NOT_FOUND; }</a>
<a name="ln318"> </a>
<a name="ln319">    return err_code;</a>
<a name="ln320">}</a>
<a name="ln321">// // // // // // // // //                // // // // // //</a>
<a name="ln322">static rd_status_t app_log_read_populate (rd_sensor_data_t * const sample,</a>
<a name="ln323">        app_log_read_state_t * const p_rs)</a>
<a name="ln324">{</a>
<a name="ln325">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln326"> </a>
<a name="ln327">    // Last memory block is the current RAM buffer, so we have valid data</a>
<a name="ln328">    // when APP_FLASH_LOG_DATA_RECORDS_NUM + 1 == p_rs-&gt;page_idx</a>
<a name="ln329">    if ( (APP_FLASH_LOG_DATA_RECORDS_NUM + 1) &lt; p_rs-&gt;page_idx)</a>
<a name="ln330">    {</a>
<a name="ln331">        err_code |= RD_ERROR_NOT_FOUND;</a>
<a name="ln332">    }</a>
<a name="ln333">    else if (p_rs-&gt;element_idx &lt; m_log_output_block.num_samples)</a>
<a name="ln334">    {</a>
<a name="ln335">        const app_log_element_t * const p_el = &amp;m_log_output_block.storage[p_rs-&gt;element_idx];</a>
<a name="ln336">        rd_sensor_data_set (sample, RD_SENSOR_TEMP_FIELD, p_el-&gt;temperature_c);</a>
<a name="ln337">        rd_sensor_data_set (sample, RD_SENSOR_HUMI_FIELD, p_el-&gt;humidity_rh);</a>
<a name="ln338">        rd_sensor_data_set (sample, RD_SENSOR_PRES_FIELD, p_el-&gt;pressure_pa);</a>
<a name="ln339">        sample-&gt;timestamp_ms = ( (uint64_t) (p_el-&gt;timestamp_s)) * 1000LLU;</a>
<a name="ln340">        p_rs-&gt;element_idx++;</a>
<a name="ln341">    }</a>
<a name="ln342">    else {} // No action required.</a>
<a name="ln343"> </a>
<a name="ln344">    return err_code;</a>
<a name="ln345">}</a>
<a name="ln346">// // // // // // //       // // // // // // // // // // //</a>
<a name="ln347">rd_status_t app_log_read (rd_sensor_data_t * const sample,</a>
<a name="ln348">                          app_log_read_state_t * const p_rs)</a>
<a name="ln349">{</a>
<a name="ln350">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln351"> </a>
<a name="ln352">    if ( (NULL != sample) &amp;&amp; (NULL != p_rs))</a>
<a name="ln353">    {</a>
<a name="ln354">        // Load new block if needed</a>
<a name="ln355">        do</a>
<a name="ln356">        {</a>
<a name="ln357">            err_code = app_log_read_load_block (p_rs);</a>
<a name="ln358"> </a>
<a name="ln359">            // Decompress block -todo.</a>
<a name="ln360">            // Check if ths block contains data in desired time range - TODO</a>
<a name="ln361">            // Fast forward to start of desired time range.</a>
<a name="ln362">            if (RD_SUCCESS == err_code) { err_code |= app_log_read_fast_forward (p_rs); }</a>
<a name="ln363">        } while ( (err_code != RD_SUCCESS)</a>
<a name="ln364"> </a>
<a name="ln365">                  &amp;&amp; (p_rs-&gt;page_idx &lt;= APP_FLASH_LOG_DATA_RECORDS_NUM));</a>
<a name="ln366"> </a>
<a name="ln367">        err_code |= app_log_read_populate (sample, p_rs); // Populate record</a>
<a name="ln368">    }</a>
<a name="ln369">    else { err_code = RD_ERROR_NULL; }</a>
<a name="ln370"> </a>
<a name="ln371">    return err_code;</a>
<a name="ln372">}</a>
<a name="ln373">// // // // // // //          // // // // // // // // // //</a>
<a name="ln374">rd_status_t app_log_config_set (const app_log_config_t * const configuration)</a>
<a name="ln375">{</a>
<a name="ln376">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln377">    uint32_t end_timestamp = m_log_input_block.end_timestamp_s;</a>
<a name="ln378"> </a>
<a name="ln379">    if (NULL == configuration) { err_code |= RD_ERROR_NULL; }</a>
<a name="ln380">    else</a>
<a name="ln381">    {</a>
<a name="ln382">        err_code |= rt_flash_store (APP_FLASH_LOG_FILE, APP_FLASH_LOG_CONFIG_RECORD,</a>
<a name="ln383">                                    &amp;configuration, sizeof (configuration));</a>
<a name="ln384"> </a>
<a name="ln385">        if (RD_SUCCESS == err_code)</a>
<a name="ln386">        {</a>
<a name="ln387">            err_code |= store_block (&amp;m_log_input_block);</a>
<a name="ln388">            RD_ERROR_CHECK (err_code, RD_SUCCESS);</a>
<a name="ln389">            memset (&amp;m_log_input_block, 0, sizeof (m_log_input_block));</a>
<a name="ln390">            m_log_input_block.start_timestamp_s = end_timestamp;</a>
<a name="ln391">            memcpy (&amp;m_log_config, configuration, sizeof (m_log_config));</a>
<a name="ln392">        }</a>
<a name="ln393">    }</a>
<a name="ln394"> </a>
<a name="ln395">    return err_code;</a>
<a name="ln396">}</a>
<a name="ln397">// // // // // // //             // // // // // // // // //</a>
<a name="ln398">rd_status_t app_log_config_get (app_log_config_t * const configuration)</a>
<a name="ln399">{</a>
<a name="ln400">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln401">    err_code |= rt_flash_load (APP_FLASH_LOG_FILE, APP_FLASH_LOG_CONFIG_RECORD,</a>
<a name="ln402">                               configuration, sizeof (app_log_config_t));</a>
<a name="ln403">    memcpy (configuration, &amp;m_log_config, sizeof (m_log_config));</a>
<a name="ln404">    return err_code;</a>
<a name="ln405">}</a>
<a name="ln406">/* @brief user request system reset via button  */</a>
<a name="ln407">// // // // /            / // // // // // // // // // // //</a>
<a name="ln408">void app_log_purge_flash (void)</a>
<a name="ln409">{</a>
<a name="ln410">    ri_flash_purge();</a>
<a name="ln411">}</a>
<a name="ln412"> </a>
<a name="ln413">#else     // RT_FLASH_ENABLED  </a>
<a name="ln414">rd_status_t app_log_init (void)                                                 // dummy</a>
<a name="ln415">{</a>
<a name="ln416">    return RD_SUCCESS;</a>
<a name="ln417">}</a>
<a name="ln418">rd_status_t app_log_process (const rd_sensor_data_t * const sample)             // dummy</a>
<a name="ln419">{</a>
<a name="ln420">    return RD_SUCCESS;</a>
<a name="ln421">}</a>
<a name="ln422">rd_status_t app_log_config_get (app_log_config_t * const configuration)         // dummy</a>
<a name="ln423">{</a>
<a name="ln424">    return RD_SUCCESS;</a>
<a name="ln425">}</a>
<a name="ln426">rd_status_t app_log_config_set (const app_log_config_t * const configuration)  // dummy</a>
<a name="ln427">{</a>
<a name="ln428">    return RD_SUCCESS;</a>
<a name="ln429">}</a>
<a name="ln430">rd_status_t app_log_read (rd_sensor_data_t * const sample,                     // dummy</a>
<a name="ln431">                          app_log_read_state_t * const p_read_state)</a>
<a name="ln432">{</a>
<a name="ln433">    return RD_ERROR_NOT_FOUND;</a>
<a name="ln434">}</a>
<a name="ln435"> </a>
<a name="ln436">void app_log_purge_flash (void)                                                 // dummy</a>
<a name="ln437">{</a>
<a name="ln438">    return;</a>
<a name="ln439">}</a>
<a name="ln440">#endif    // RT_FLASH_ENABLED</a>

</code></pre>
<div class="balloon" rel="82"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2568/" target="_blank">V2568</a> Both operands of the '%' operator should have the same essential type. The current types are: 'signed' and 'unsigned'.</p></div>
<div class="balloon" rel="82"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '(record_idx + num_tries) % ((16U) - 2U)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="84"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '((0xF0U) << 8u) + record_slot' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="85"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '(0xF0U)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="91"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2600/" target="_blank">V2600</a> The function with the 'snprintf' name should not be used.</p></div>
<div class="balloon" rel="96"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2600/" target="_blank">V2600</a> The function with the 'snprintf' name should not be used.</p></div>
<div class="balloon" rel="110"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '(0xF0U)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="112"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the 'sizeof (app_log_record_t)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="124"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the 'record_idx % ((16U) - 2U)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="138"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '(0xF0U)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="139"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '((0xF0U) << 8u) + record_idx' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="153"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '(0xF0U)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="154"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '(0xEFU)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="160"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '(0xF0U)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="161"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '(0xEFU)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="166"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2600/" target="_blank">V2600</a> The function with the 'snprintf' name should not be used.</p></div>
<div class="balloon" rel="166"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'snprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="192"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2594/" target="_blank">V2594</a> Controlling expressions should not be invariant. The result of the '(1U << 2U) == err_code' expression in the 'if' statement is always false.</p></div>
<div class="balloon" rel="194"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '(0xF0U)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="194"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '(0x01U)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="198"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2594/" target="_blank">V2594</a> Controlling expressions should not be invariant. The result of the '(0U) == err_code' expression in the 'if' statement is always true.</p></div>
<div class="balloon" rel="212"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2613/" target="_blank">V2613</a> Operand that is a composite expression has more narrow essential type than the other operand.</p></div>
<div class="balloon" rel="216"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2568/" target="_blank">V2568</a> Both operands of the '==' operator should have the same essential type. The current types are: 'signed' and 'unsigned'.</p></div>
<div class="balloon" rel="216"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="229"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2568/" target="_blank">V2568</a> Both operands of the '-' operator should have the same essential type. The current types are: 'signed' and 'unsigned'.</p></div>
<div class="balloon" rel="232"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2568/" target="_blank">V2568</a> Both operands of the '-' operator should have the same essential type. The current types are: 'signed' and 'unsigned'.</p></div>
<div class="balloon" rel="242"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the 'sample->timestamp_ms / 1000U' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="259"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2568/" target="_blank">V2568</a> Both operands of the '==' operator should have the same essential type. The current types are: 'signed' and 'unsigned'.</p></div>
<div class="balloon" rel="260"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2568/" target="_blank">V2568</a> Both operands of the '==' operator should have the same essential type. The current types are: 'signed' and 'unsigned'.</p></div>
<div class="balloon" rel="263"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '(0xF0U)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="264"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '((0xF0U) << 8u) + p_rs->page_idx' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="272"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '(0xF0U)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="273"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '((0xF0U) << 8u) + p_rs->page_idx' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="276"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="283"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="329"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2568/" target="_blank">V2568</a> Both operands of the '+' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="382"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '(0xF0U)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="382"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '(0x01U)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="401"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '(0xF0U)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="401"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2572/" target="_blank">V2572</a> The value of the '(0x01U)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="22"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2587/" target="_blank">V2587</a> The '//' and '/*' character sequences should not appear within comments.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
