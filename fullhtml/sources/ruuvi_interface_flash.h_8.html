
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ruuvi_interface_flash.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">#ifndef  RUUVI_INTERFACE_FLASH_H</a>
<a name="ln2">#define  RUUVI_INTERFACE_FLASH_H</a>
<a name="ln3"> </a>
<a name="ln4">/**</a>
<a name="ln5"> * @defgroup Flash Flash storage.</a>
<a name="ln6"> * @brief Interface and implementations for storing data into flash in a persistent manner.</a>
<a name="ln7"> *</a>
<a name="ln8"> */</a>
<a name="ln9">/** @{ */</a>
<a name="ln10">/**</a>
<a name="ln11"> * @file ruuvi_interface_flash.h</a>
<a name="ln12"> * @author Otso Jousimaa &lt;otso@ojousima.net&gt;</a>
<a name="ln13"> * @date 2020-12-10</a>
<a name="ln14"> * @copyright Ruuvi Innovations Ltd, license BSD-3-Clause.</a>
<a name="ln15"> * @brief Interface functions to persistent flash storage.</a>
<a name="ln16"> *</a>
<a name="ln17"> * Flash is stored to pages which are ideally of same size as the underlying physical write/erase unit.</a>
<a name="ln18"> * Each page may contain N records. Underlying driver is allowed to arrange pages and records in any manner</a>
<a name="ln19"> * to implement wear leveling.</a>
<a name="ln20"> * Underlying driver is allowed to trigger garbage collection on write, which makes runtime of operation</a>
<a name="ln21"> * undeterministic.</a>
<a name="ln22"> *</a>
<a name="ln23"> */</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;ruuvi_driver_enabled_modules.h&quot;</a>
<a name="ln26">#include &quot;ruuvi_driver_error.h&quot;</a>
<a name="ln27">#include &lt;stddef.h&gt;</a>
<a name="ln28"> </a>
<a name="ln29">/** @brief Enable implementation selected by application */</a>
<a name="ln30">#if RI_FLASH_ENABLED</a>
<a name="ln31">#  define RUUVI_NRF5_SDK15_FLASH_ENABLED RUUVI_NRF5_SDK15_ENABLED</a>
<a name="ln32">#endif</a>
<a name="ln33"> </a>
<a name="ln34">#ifdef APP_FLASH_PAGES</a>
<a name="ln35">#   define RI_FLASH_PAGES APP_FLASH_PAGES</a>
<a name="ln36">#else</a>
<a name="ln37">#   define RI_FLASH_PAGES (10U)</a>
<a name="ln38">#endif</a>
<a name="ln39"> </a>
<a name="ln40">/**</a>
<a name="ln41"> * @brief Get total size of usable flash, excluding any overhead bytes.</a>
<a name="ln42"> *</a>
<a name="ln43"> * @param[out] size Size of useable storage in bytes.</a>
<a name="ln44"> * @retval RD_SUCCESS on success.</a>
<a name="ln45"> * @retval RD_ERROR_NULL if size is null.</a>
<a name="ln46"> * @retval RD_ERROR_INVALID_STATE if flash storage is not initialized.</a>
<a name="ln47"> * @retval error code from stack on other error.</a>
<a name="ln48"> */</a>
<a name="ln49">rd_status_t ri_flash_total_size_get (size_t * size);</a>
<a name="ln50"> </a>
<a name="ln51">/**</a>
<a name="ln52"> * @brief Get size of usable page, excluding any overhead bytes</a>
<a name="ln53"> * If returned value is N, a record of N bytes must fit in one page.</a>
<a name="ln54"> *</a>
<a name="ln55"> * @param[out] size Size of useable storage in bytes.</a>
<a name="ln56"> * @retval RD_SUCCESS on success.</a>
<a name="ln57"> * @retval RD_ERROR_NULL if size is null.</a>
<a name="ln58"> * @retval RD_ERROR_INVALID_STATE if flash storage is not initialized.</a>
<a name="ln59"> * @retval error code from stack on other error.</a>
<a name="ln60"> */</a>
<a name="ln61">rd_status_t ri_flash_page_size_get (size_t * size);</a>
<a name="ln62"> </a>
<a name="ln63">/**</a>
<a name="ln64"> * @brief Get total size of free flash.</a>
<a name="ln65"> *</a>
<a name="ln66"> * @param[out] size  size of useable storage in bytes.</a>
<a name="ln67"> * @retval RD_SUCCESS on success.</a>
<a name="ln68"> * @retval RD_ERROR_NULL if size is null.</a>
<a name="ln69"> * @retval RD_ERROR_INVALID_STATE if flash storage is not initialized.</a>
<a name="ln70"> * @retval error code from stack on other error.</a>
<a name="ln71"> */</a>
<a name="ln72">rd_status_t ri_flash_free_size_get (size_t * size);</a>
<a name="ln73"> </a>
<a name="ln74">/**</a>
<a name="ln75"> * @brief Mark a record for deletion.</a>
<a name="ln76"> *</a>
<a name="ln77"> * Note that this only marks the record as freed</a>
<a name="ln78"> * and does not physically overwrite the flash.</a>
<a name="ln79"> * The function only starts the operation and returns immediately.</a>
<a name="ln80"> *</a>
<a name="ln81"> * @param[in] file_id ID of file which contains the record.</a>
<a name="ln82"> * @param[in] record_id ID of record to delete.</a>
<a name="ln83"> *</a>
<a name="ln84"> * @retval RD_SUCCESS if deletion was queued.</a>
<a name="ln85"> * @retval RD_ERROR_INVALID_STATE if flash storage is not initialized.</a>
<a name="ln86"> * @retval RD_ERROR_BUSY if another operation was ongoing.</a>
<a name="ln87"> * @retval RD_ERROR_NOT_FOUND if give record was not found.</a>
<a name="ln88"> */</a>
<a name="ln89">rd_status_t ri_flash_record_delete (const uint32_t file_id,</a>
<a name="ln90">                                    const uint32_t record_id);</a>
<a name="ln91"> </a>
<a name="ln92">/**</a>
<a name="ln93"> * @brief Set data to record in page.</a>
<a name="ln94"> *</a>
<a name="ln95"> * Automatically runs garbage collection if record cannot fit on page.</a>
<a name="ln96"> * Returns after data is successfully written or error has occured.</a>
<a name="ln97"> *</a>
<a name="ln98"> * @param[in] page_id ID of a page. Can be random number.</a>
<a name="ln99"> * @param[in] record_id ID of a record. Can be a random number.</a>
<a name="ln100"> * @param[in] data_size size data to store</a>
<a name="ln101"> * @param[in] data pointer to data to store.</a>
<a name="ln102"> * @retval RD_SUCCESS on success</a>
<a name="ln103"> * @retval RD_ERROR_NULL if data is null</a>
<a name="ln104"> * @retval RD_ERROR_INVALID_STATE if flash storage is not initialized</a>
<a name="ln105"> * @retval RD_ERROR_BUSY if another operation is ongoing.</a>
<a name="ln106"> * @retval RD_ERROR_DATA_SIZE if record is too large to fit on page</a>
<a name="ln107"> * @retval RD_ERROR_NO_MEM if this record cannot fit on page.</a>
<a name="ln108"> * @retval error code from stack on other error</a>
<a name="ln109"> */</a>
<a name="ln110">rd_status_t ri_flash_record_set (const uint32_t page_id,</a>
<a name="ln111">                                 const uint32_t record_id, const size_t data_size, const void * const data);</a>
<a name="ln112"> </a>
<a name="ln113">/**</a>
<a name="ln114"> * @brief Get data from record in page.</a>
<a name="ln115"> *</a>
<a name="ln116"> * Returns after data is read and ready to be used or error has occured.</a>
<a name="ln117"> *</a>
<a name="ln118"> * @param[in] page_id: ID of a page. Can be random number.</a>
<a name="ln119"> * @param[in] record_id: ID of a record. Can be a random number.</a>
<a name="ln120"> * @param[in,out] data_size input: Maximum size of data to retrieve. Output: Number of bytes retrieved.</a>
<a name="ln121"> * @param[in] data pointer to memory which will be filled with retrieved data.</a>
<a name="ln122"> * @retval RD_SUCCESS on success.</a>
<a name="ln123"> * @retval RD_ERROR_NULL if data is null.</a>
<a name="ln124"> * @retval RD_ERROR_INVALID_STATE if flash storage is not initialized.</a>
<a name="ln125"> * @retval RD_ERROR_NOT_FOUND if given page id does not exist or if given record_id does not exist on given page.</a>
<a name="ln126"> * @retval error code from stack on other error.</a>
<a name="ln127"> */</a>
<a name="ln128">rd_status_t ri_flash_record_get (const uint32_t page_id, const uint32_t record_id,</a>
<a name="ln129">                                 const size_t data_size, void * const data);</a>
<a name="ln130"> </a>
<a name="ln131">/**</a>
<a name="ln132"> * @brief Run garbage collection.</a>
<a name="ln133"> *</a>
<a name="ln134"> * @retval RD_SUCCESS on success.</a>
<a name="ln135"> * @retval RD_INVALID_STATE if flash is not initialized.</a>
<a name="ln136"> * @retval error code from stack on other error.</a>
<a name="ln137"> */</a>
<a name="ln138">rd_status_t ri_flash_gc_run (void);</a>
<a name="ln139"> </a>
<a name="ln140">/**</a>
<a name="ln141"> * Initialize flash.</a>
<a name="ln142"> * After initialization other flash functions can be used.</a>
<a name="ln143"> *</a>
<a name="ln144"> * @retval RD_SUCCESS on success.</a>
<a name="ln145"> * @retval RD_ERROR_INVALID_STATE if flash is already initialized.</a>
<a name="ln146"> * @retval RD_ERROR_INVALID_LENGTH if space configured in linker does not</a>
<a name="ln147"> *                                 match space reserved by implementation.</a>
<a name="ln148"> */</a>
<a name="ln149">rd_status_t ri_flash_init (void);</a>
<a name="ln150"> </a>
<a name="ln151">/**</a>
<a name="ln152"> * @brief Unintialize flash.</a>
<a name="ln153"> * After uninitialization only initialization can be used.</a>
<a name="ln154"> *</a>
<a name="ln155"> * @retval RD_SUCCESS on success.</a>
<a name="ln156"> */</a>
<a name="ln157">rd_status_t ri_flash_uninit (void);</a>
<a name="ln158"> </a>
<a name="ln159">/**</a>
<a name="ln160"> * @brief Purge flash.</a>
<a name="ln161"> *</a>
<a name="ln162"> * This function is used to &quot;rescue&quot; flash which cannot be initialized normally,</a>
<a name="ln163"> * for example after data corruption. Completely erases all data content on flash.</a>
<a name="ln164"> * Does not erase application files.</a>
<a name="ln165"> *</a>
<a name="ln166"> * This function is blocking, returns once flash is cleared.</a>
<a name="ln167"> */</a>
<a name="ln168">void ri_flash_purge (void);</a>
<a name="ln169"> </a>
<a name="ln170">/**</a>
<a name="ln171"> * @brief Check if flash is busy.</a>
<a name="ln172"> *</a>
<a name="ln173"> * @return True if flash is running an operation.</a>
<a name="ln174"> * @return False if flash is idle.</a>
<a name="ln175"> */</a>
<a name="ln176">bool ri_flash_is_busy();</a>
<a name="ln177"> </a>
<a name="ln178">/** @} */</a>
<a name="ln179"> </a>
<a name="ln180">#endif</a>

</code></pre>
<div class="balloon" rel="176"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2601/" target="_blank">V2601</a> Functions should be declared in prototype form with named parameters.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
