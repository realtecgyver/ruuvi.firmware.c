
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ruuvi_library_compress.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">#ifndef RUUVI_LIBRARY_COMPRESS_H</a>
<a name="ln2">#define RUUVI_LIBRARY_COMPRESS_H</a>
<a name="ln3">/**</a>
<a name="ln4">* @file ruuvi_library_compress.h</a>
<a name="ln5">* @author Oleg Protasevich</a>
<a name="ln6">* @date 2020-06-16</a>
<a name="ln7">* @brief Compression API</a>
<a name="ln8">* @copyright Copyright 2020 Ruuvi Innovations.</a>
<a name="ln9">*   This project is released under the BSD-3-Clause License.</a>
<a name="ln10">*</a>
<a name="ln11">*</a>
<a name="ln12">*/</a>
<a name="ln13"> </a>
<a name="ln14">#include &lt;stdint.h&gt;</a>
<a name="ln15">#include &lt;stdio.h&gt;</a>
<a name="ln16">#include &lt;stdbool.h&gt;</a>
<a name="ln17">#include &quot;liblzf-3.6/lzf.h&quot;</a>
<a name="ln18"> </a>
<a name="ln19">// #define RL_COMPRESS_CONVERT_TO_INT Drops floating precision.</a>
<a name="ln20"> </a>
<a name="ln21">#define RL_COMPRESS_SUCCESS                (0U)       ///&lt; Success</a>
<a name="ln22">#define RL_COMPRESS_ERROR_INVALID_PARAM    (1U&lt;&lt;4U)   ///&lt; Invalid Parameter</a>
<a name="ln23">#define RL_COMPRESS_ERROR_INVALID_STATE    (1U&lt;&lt;5U)   ///&lt; Invalid state, operation disallowed in this state</a>
<a name="ln24">#define RL_COMPRESS_ERROR_NULL             (1U&lt;&lt;11U)  ///&lt; Null Pointer</a>
<a name="ln25">#define RL_COMPRESS_ERROR_INTERNAL         (1U&lt;&lt;12U)  ///&lt; Algorithm error</a>
<a name="ln26">#define RL_COMPRESS_ERROR_NOT_FOUND        (1U&lt;&lt;13U)  ///&lt; No matching data found.</a>
<a name="ln27">#define RL_COMPRESS_END                    (1U&lt;&lt;22U)  ///&lt; Compress/Decompress ended</a>
<a name="ln28">#define RL_COMPRESS_LIMIT_REACHED          (1U&lt;&lt;23U)  ///&lt; Maximum compression limit reached.</a>
<a name="ln29">#define RL_COMPRESS_OUT2BIG                (1U&lt;&lt;24U)  ///&lt; Compressed data is larger than input. Store uncompressed data. </a>
<a name="ln30">#define RL_COMPRESS_START                  (1U&lt;&lt;25U)  ///&lt; Start de/compress operation</a>
<a name="ln31">#define RL_COMPRESS_DECOMPRESS_DONE        (1U&lt;&lt;26U)  ///&lt; Data is decompressed.</a>
<a name="ln32"> </a>
<a name="ln33">#define RL_COMPRESS_STATE_SIZE             (1U &lt;&lt; (HLOG)) //!&lt; hashtable size.</a>
<a name="ln34">#define RL_COMPRESS_COMPRESS_SIZE          (4000U)        //!&lt; Flash page is 4096 bytes, leave space for headers.</a>
<a name="ln35">/**</a>
<a name="ln36"> * @brief Maximum compression ratio is COMPRESS_SIZE/DECOMPRESS_SIZE, but increases RAM usage.</a>
<a name="ln37"> */</a>
<a name="ln38">#define RL_COMPRESS_DECOMPRESS_SIZE        (2U * RL_COMPRESS_COMPRESS_SIZE)</a>
<a name="ln39">#define RL_COMPRESS_FIELD_NUM              (3U) //!&lt; Number of fields to compress</a>
<a name="ln40">/**</a>
<a name="ln41"> * Compression overhead allows small percentage of wasted space in block.</a>
<a name="ln42"> * Minimum should be 4 % of RL_COMPRESS_COMPRESS_SIZE to allow for incompressible data.</a>
<a name="ln43"> * Larger values reduce algorithm reruns, but spend more space.</a>
<a name="ln44"> */</a>
<a name="ln45">#define RL_COMPRESS_OVERHEAD               (RL_COMPRESS_COMPRESS_SIZE / 20U)</a>
<a name="ln46"> </a>
<a name="ln47">typedef uint32_t timestamp_t;</a>
<a name="ln48">typedef uint32_t ret_type_t;///&lt; bitfield for representing errors</a>
<a name="ln49">typedef LZF_HSLOT rl_compress_algo_state_t[RL_COMPRESS_STATE_SIZE];</a>
<a name="ln50"> </a>
<a name="ln51">#pragma pack(push, 1)</a>
<a name="ln52">typedef struct</a>
<a name="ln53">{</a>
<a name="ln54">    timestamp_t time;</a>
<a name="ln55">    float payload[RL_COMPRESS_FIELD_NUM];</a>
<a name="ln56">} rl_data_t;</a>
<a name="ln57"> </a>
<a name="ln58">typedef struct</a>
<a name="ln59">{</a>
<a name="ln60">    rl_compress_algo_state_t algo_state; //!&lt; Hashtable, memset to 0 to reset. 4 kB</a>
<a name="ln61">    uint8_t compress_block[RL_COMPRESS_COMPRESS_SIZE]; // Compressed block.</a>
<a name="ln62">    uint8_t decompress_block[RL_COMPRESS_DECOMPRESS_SIZE]; // Decompressed block.</a>
<a name="ln63">    size_t compressed_size;   //!&lt; Number of compressed bytes in compress block.</a>
<a name="ln64">    size_t decompressed_size; //!&lt; Number of uncompressed bytes in decompress block.</a>
<a name="ln65">    size_t next_decompression; //!&lt; Counter for number of decompressed bytes before trying next decompression.</a>
<a name="ln66">    rl_data_t * next_sample;  //!&lt; Pointer to next sample in decompression.</a>
<a name="ln67">    ret_type_t compress_state; //!&lt; State of compression.</a>
<a name="ln68">} rl_compress_state_t;</a>
<a name="ln69">#pragma pack(pop)</a>
<a name="ln70"> </a>
<a name="ln71">/**</a>
<a name="ln72"> * @brief Ruuvi Library compress function.</a>
<a name="ln73"> * Takes a sensor data sample in and appends it to given data block.</a>
<a name="ln74"> *</a>
<a name="ln75"> * It is assumed that data is appended in linear order,</a>
<a name="ln76"> * new sample has always greater timestamp than previous.</a>
<a name="ln77"> *</a>
<a name="ln78"> * @param[in] data Sensor data to compress, 1 sample.</a>
<a name="ln79"> * @param[out] block Pointer to buffer to which compressed data is placed.</a>
<a name="ln80"> * @param[in] block_size Size of block.</a>
<a name="ln81"> * @param[in,out] state In: State of compression algorithm before adding latest data.</a>
<a name="ln82"> *                      Out: State of compression algorithm after adding latest data.</a>
<a name="ln83"> * @retval RL_SUCCESS If compression was successful.</a>
<a name="ln84"> * @retval RL_ERROR_NULL If given a NULL as a parameter.</a>
<a name="ln85"> * @retval RL_COMPRESS_END If the block is considered full.</a>
<a name="ln86"> *                         Block is ready to be stored to non-volatile memory.</a>
<a name="ln87"> * @retval RL_COMPRESS_OUT2BIG If compressed data is larger than uncompressed data.</a>
<a name="ln88"> *                             In this case uncompressed data should be stored,</a>
<a name="ln89"> *                             compressed data may be invalid if it doesn't fit</a>
<a name="ln90"> *                             into block.</a>
<a name="ln91"> *</a>
<a name="ln92"> *</a>
<a name="ln93"> */</a>
<a name="ln94">ret_type_t rl_compress (const rl_data_t * const data,</a>
<a name="ln95">                        uint8_t * const block,</a>
<a name="ln96">                        const size_t block_size,</a>
<a name="ln97">                        rl_compress_state_t * const state);</a>
<a name="ln98">/**</a>
<a name="ln99"> * @brief Ruuvi Library decompress function.</a>
<a name="ln100"> * Looks up next sample after given timestamp and returns it via output parameter.</a>
<a name="ln101"> *</a>
<a name="ln102"> * Usage:</a>
<a name="ln103"> * @code</a>
<a name="ln104"> * ret_type_t status;</a>
<a name="ln105"> * rl_data_t data;</a>
<a name="ln106"> * uint8_t* block = get_next_block();</a>
<a name="ln107"> * size_t block_size = DATA_BLOCK_SIZE;</a>
<a name="ln108"> * rl_decompress_state_t state = { 0 }; // zeroed state initially.</a>
<a name="ln109"> * timestamp_t start_timestamp = 0; // Get all the data from boot.</a>
<a name="ln110"> * while(RL_COMPRESS_SUCCESS == status)</a>
<a name="ln111"> * {</a>
<a name="ln112"> *   // This pseudocode fails if no data is found and it misses last sample.</a>
<a name="ln113"> *   status = rl_decompress(&amp;data, block, block_size, &amp;state, &amp;start_timestamp);</a>
<a name="ln114"> *   do_something_with_data(&amp;data);</a>
<a name="ln115"> * }</a>
<a name="ln116"> * @endcode</a>
<a name="ln117"> *</a>
<a name="ln118"> * @param[out] data Next sample from block. Not modified if no data was found in block.</a>
<a name="ln119"> * @param[in]  block Pointer to compressed buffer with sensor data.</a>
<a name="ln120"> * @param[in]  block_size Size of block.</a>
<a name="ln121"> * @param[in,out] state In: State of decompression algorithm before decompressing next data point. Out: State of decompression algorithm after decompressing next data point.</a>
<a name="ln122"> * @param[in,out] start_timestamp In: Earliest timestamp to accept. Out: Timestamp of returned data.</a>
<a name="ln123"> * @retval Status of decompression, such as more available or not_found.</a>
<a name="ln124"> *</a>
<a name="ln125"> *</a>
<a name="ln126"> *</a>
<a name="ln127"> */</a>
<a name="ln128">ret_type_t rl_decompress (rl_data_t * data,</a>
<a name="ln129">                          uint8_t * block,</a>
<a name="ln130">                          size_t block_size,</a>
<a name="ln131">                          rl_compress_state_t * state,</a>
<a name="ln132">                          timestamp_t * start_timestamp);</a>
<a name="ln133"> </a>
<a name="ln134">#endif</a>

</code></pre>
<div class="balloon" rel="108"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2587/" target="_blank">V2587</a> The '//' and '/*' character sequences should not appear within comments.</p></div>
<div class="balloon" rel="109"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2587/" target="_blank">V2587</a> The '//' and '/*' character sequences should not appear within comments.</p></div>
<div class="balloon" rel="112"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v2587/" target="_blank">V2587</a> The '//' and '/*' character sequences should not appear within comments.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
